{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func createAuction(duration: Int, minBid: Int) = {
    let lastAuctionIdKey = "last_auction_id"
    #let currentKey = toBase58String(i.caller.bytes)
    #let lastAuctionId = extract(getInteger(this, lastAuctionIdKey))
    let lastAuctionId = match getInteger(this, lastAuctionIdKey) {
                case a:Int => a
                case _ => 0
    }

    let id = lastAuctionId + 1
    let newAuctionId = toString(id)
    let ownerWallet = toBase58String(i.caller.bytes)
    let pmt = value(i.payment)
    if (!isDefined(pmt.assetId)) then throw("Send some tokens, but not Waves")
    else {
        let assetId = toBase58String(value(pmt.assetId))
        let auctionDurationKey = "auction_" + newAuctionId + "_duration"
        let auctionMinBidKey = "auction_" + newAuctionId + "_min_bid"
        let auctionLastBidKey = "auction_" + newAuctionId + "_last_bid"
        let auctionOwnerKey = "auction_" + newAuctionId + "_owner"
        let auctionAmountKey = "auction_" + newAuctionId + "_amount"
        let auctionAssetIdKey = "auction_" + newAuctionId + "_asset_id"
        let userBalanceKey = "balance_" + ownerWallet + "_" + assetId

        let currentAmount = match getInteger(this, userBalanceKey) {
                case a:Int => a
                case _ => 0
        }
        let newAmount = currentAmount + pmt.amount


        WriteSet([
            DataEntry(auctionDurationKey, height + duration),
            DataEntry(auctionMinBidKey, minBid),
            DataEntry(auctionLastBidKey, 0),
            DataEntry(auctionOwnerKey, ownerWallet),
            DataEntry(auctionAmountKey, pmt.amount),
            DataEntry(auctionAssetIdKey, assetId),
            DataEntry(userBalanceKey, newAmount),
            DataEntry(lastAuctionIdKey, id)
        ])
    }
}

@Callable(i)
func bid(auctionId: Int, bidAmount: Int) = {
    let newAuctionId = toString(auctionId)
    let auctionDurationKey = "auction_" + newAuctionId + "_duration"
    let auctionMinBidKey = "auction_" + newAuctionId + "_min_bid"
    let auctionLastBidKey = "auction_" + newAuctionId + "_last_bid"
    let auctionOwnerKey = "auction_" + newAuctionId + "_owner"
    let lastAuctionIdKey = "last_auction_id"

    let auctionDuration = extract(getInteger(this, auctionDurationKey))
    let auctionMinBid = extract(getInteger(this, auctionMinBidKey))
    let auctionLastBid = extract(getInteger(this, auctionLastBidKey))
    let auctionOwner = extract(getString(this, auctionOwnerKey))
    let lastAuctionId = extract(getInteger(this, lastAuctionIdKey))

    let pmt = extract(i.payment)
    let isValidHeight = auctionDuration <= height
    let isValidMinBid = bidAmount >= auctionMinBid
    let isValidCurrentBid = bidAmount > auctionLastBid
    let isAmountExists = assetBalance(i.caller, pmt.assetId) >= bidAmount
    let isValidSender = auctionOwner != toBase58String(i.caller.bytes)

    if(!isValidHeight) then throw("Action already end")
    else if(!isValidMinBid) then throw("Bid less that min")
    else if(!isValidCurrentBid) then throw("Last bid more than yours")
    else if(!isAmountExists) then throw("Not enough balance in your wallet")
    else if(!isValidSender) then throw("You can not bid in your auction")
    else if (isDefined(pmt.assetId)) then throw("Can transfer Waves only")
    else {
        WriteSet([
            DataEntry(auctionLastBidKey, bidAmount)
        ])
    }
}

@Callable(i)
func validateEmail(email: String, code: String) = {
    let isVerifiedKey = email + "_is_valid"
    let isVerified = isDefined(getBoolean(this, isVerifiedKey)) && extract(getBoolean(this, isVerifiedKey))
    if (isVerified) then throw("Email already verified")
    else {
        let key = email + "_code_hash"
        let currentKey = toBase58String(i.caller.bytes)
        let originalCode = extract(getString(this, key))
        let result = isDefined(getString(this, key)) && sha256(fromBase64String(code)) == fromBase64String(originalCode)
        if(!result) then throw("Incorrect code")
        else{
            WriteSet([
                DataEntry(email + "_is_valid", result),
                DataEntry(email + "_owner", currentKey)
            ])
        }
    }
}

@Callable(i)
func payToEmail(email: String) = {
    let isVerifiedKey = email + "_is_valid"
    let ownerKey = email + "_owner"
    let isVerified = isDefined(getBoolean(this, isVerifiedKey)) && extract(getBoolean(this, isVerifiedKey))
    let paymentReceiver = Address(fromBase58String(extract(getString(this, ownerKey))))
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) then throw("Can transfer Waves only")
    else {
        if (!isVerified)
            then throw("Email not verified")
        else {
            TransferSet([ScriptTransfer(paymentReceiver, pmt.amount, unit)])
        }
     }
}

@Verifier(tx)
func verify() = {
    true
}
